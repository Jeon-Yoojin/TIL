1. 상황
   - 비동기 함수를 병렬로 실행한 이후에 `Promise.all()`로 결과를 반환하는 부분에서 중간에 한 번 오류가 나서 전체 배열을 받지 못하게 됨
   - Promise.all은 하나라도 실패하면 에러를 던지므로 실행 결과를 알 수 없음
2. 알게된 것

   1. `Promise` 사용?

      1. `Promise.allSettled`를 사용하면 이와 같은 문제상황을 해결할 수 있다.
      2. allSettled를 사용하면 각각의 비동기 함수를 병렬로 실행하고, 실행 결과와 함께 value를 리턴하게 된다.
      3. 따라서 성공한 결과만 가져오려면 (원래 실행의 목적)

         ```tsx
         const results = await Promise.allSettled(tasks);

         return results.map((r) => (r.status === "fulfilled" ? r.value : null));
         ```

         이렇게 한 번 더 필터링을 해주면 된다.

   2. 나쁘지 않다. 하지만 더 좋은 방법이 있을까..?

      1. 단발성 실행은 Promise로 해결이 가능하지만, 복잡한 비동기 동작이 엮여 있는 경우에는 Promise로는 해결이 힘들어진다.
      2. 예를 들어, **다음과 같은 상황**에서의 처리를 어떻게 Promise로 할 수 있을까?
         1. 외부 API 호출, 실패하면 1초 간격으로 최대 3번 재시도
         2. DB에서 사용자 불러오기 → 캐시에서 토큰 확인 → 없으면 외부 인증 서비스 호출 → 실패하면 3초 뒤 재시도
      3. 스트림, 복잡한 비동기 처리는? `rxjs`를 이용해 보면 어떨까?

         1. Promise는 실행이 시작되면 중간에 취소/개입이 불가능하다.
         2. Observable은 데이터 스트림을 다루기 때문에 흐름 제어를 훨씬 직관적으로 표현할 수 있다. 2에서 든 예시를 보자.

            1. API 요청 실패 시 재시도

               ```tsx
               import { from, of } from "rxjs";
               import { retry, catchError } from "rxjs/operators";

               from(fetch("/api/data"))
                 .pipe(
                   retry(3), // 최대 3번 재시도
                   catchError((err) =>
                     of({ error: true, message: err.message })
                   )
                 )
                 .subscribe((result) => console.log(result));
               ```

            2. 복잡한 비동기 의존 관계

               ```tsx
               import { from, timer } from "rxjs";
               import { switchMap, retryWhen, delayWhen } from "rxjs/operators";

               function getUserFromDB() {
                 /* ... */
               }
               function getTokenFromCache() {
                 /* ... */
               }
               function callAuthService() {
                 /* ... */
               }

               from(getUserFromDB())
                 .pipe(
                   switchMap(
                     (user) =>
                       getTokenFromCache(user.id) ?? callAuthService(user)
                   ),
                   retryWhen(
                     (errors) => errors.pipe(delayWhen(() => timer(3000))) // 3초 후 재시도
                   )
                 )
                 .subscribe((token) => console.log(token));
               ```

         3. 공식 문서에서 확인할 수 있는 rxjs 활용법 - `Interceptor`

            1. 인터셉터는 두 개의 인수를 받는 intercept() 메소드를 구현해야 한다. intercept 메소드는 다음과 같은 두 개의 인자를 받는다. `ExecutionContext`, `CallHandler`
            2. 이때 두번째 인수인 `CallHandler`는 인터셉터의 특정 지점에서 라우트 핸들러 메소드를 호출할 수 있도록 한다. → 요청/응답 스트림을 효과적으로 래핑함
            3. CallHandler가 구현하는 handle() 메소드는 Observable을 리턴하기 때문에, 우리는 observable을 다루는 rxjs를 사용할 수 있다!

               ```tsx
               // logging.interceptor.ts
               import {
                 Injectable,
                 NestInterceptor,
                 ExecutionContext,
                 CallHandler,
               } from "@nestjs/common";
               import { Observable } from "rxjs";
               import { tap } from "rxjs/operators";

               @Injectable()
               export class LoggingInterceptor implements NestInterceptor {
                 intercept(
                   context: ExecutionContext,
                   next: CallHandler
                 ): Observable<any> {
                   console.log("Before...");

                   const now = Date.now();
                   return next
                     .handle()
                     .pipe(
                       tap(() => console.log(`After... ${Date.now() - now}ms`))
                     );
                 }
               }
               ```

               예를 들어 `POST /cats` 요청을 처리하는 API가 있다고 가정해보자.

               - 요청은 `CatsController` 내부의 `create()` 핸들러에 의해 처리된다.
               - 만약 인터셉터가 `handle()` 메서드를 호출하지 않는다면, `create()` 메서드는 실행되지 않는다. (실제 컨트롤러 메소드)
               - `handle()` 메서드가 실행되면, (`Observable`이 리턴) `create()` 핸들러는 트리거된다.
               - 응답 스트림이 `Observable`로부터 수신된다면, 부가적인 연산이 행해진 후 요청자에게 최종 결과가 리턴된다.

3. 마무리
   1. NestJS 내부에서 프레임워크 전체 실행 흐름을 하나의 스트림 파이프라인으로 묶기 위해서 Observable을 사용한다. -> Observable을 다룰 수 있는 rxjs를 사용하는 것이 좋다.
   2. 번외로, rxjs는 프론트에서 여러 비동기 처리를 위해서도 rxjs가 유용하게 쓰인다. 복잡한 비동기 처리를 선언적으로, 직관적으로 표현할 수 있음
   3. 단순한 비동기 실행에는 Promise도 충분하지만, 실무에서 마주치는 복잡한 비동기 로직을 다루기 위해서는 rxjs가 더 적합하다는 것을 배웠다.
